diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
index 12bf9068236c..c18d2cab462b 100644
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -1761,6 +1761,14 @@ var gBrowserInit = {
 
     BrowserWindowTracker.track(window);
 
+    gNavToolbox.palette = document.getElementById("BrowserToolbarPalette");
+    gNavToolbox.palette.remove();
+    let areas = CustomizableUI.areas;
+    areas.splice(areas.indexOf(CustomizableUI.AREA_FIXED_OVERFLOW_PANEL), 1);
+    for (let area of areas) {
+      let node = document.getElementById(area);
+      CustomizableUI.registerToolbarNode(node);
+    }
     BrowserSearch.initPlaceHolder();
 
     // Hack to ensure that the various initial pages favicon is loaded
diff --git a/browser/components/customizableui/CustomizableUI.jsm b/browser/components/customizableui/CustomizableUI.jsm
index de39b04a7b53..fad092a83922 100644
--- a/browser/components/customizableui/CustomizableUI.jsm
+++ b/browser/components/customizableui/CustomizableUI.jsm
@@ -237,7 +237,6 @@ var CustomizableUIInternal = {
     this.registerArea(
       CustomizableUI.AREA_NAVBAR,
       {
-        legacy: true,
         type: CustomizableUI.TYPE_TOOLBAR,
         overflowable: true,
         defaultPlacements: navbarPlacements,
@@ -250,7 +249,6 @@ var CustomizableUIInternal = {
       this.registerArea(
         CustomizableUI.AREA_MENUBAR,
         {
-          legacy: true,
           type: CustomizableUI.TYPE_TOOLBAR,
           defaultPlacements: ["menubar-items"],
           defaultCollapsed: true,
@@ -262,7 +260,6 @@ var CustomizableUIInternal = {
     this.registerArea(
       CustomizableUI.AREA_TABSTRIP,
       {
-        legacy: true,
         type: CustomizableUI.TYPE_TOOLBAR,
         defaultPlacements: [
           "tabbrowser-tabs",
@@ -276,7 +273,6 @@ var CustomizableUIInternal = {
     this.registerArea(
       CustomizableUI.AREA_BOOKMARKS,
       {
-        legacy: true,
         type: CustomizableUI.TYPE_TOOLBAR,
         defaultPlacements: ["personal-bookmarks"],
         defaultCollapsed: true,
@@ -714,7 +710,7 @@ var CustomizableUIInternal = {
 
     let areaIsKnown = gAreas.has(aName);
     let props = areaIsKnown ? gAreas.get(aName) : new Map();
-    const kImmutableProperties = new Set(["type", "legacy", "overflowable"]);
+    const kImmutableProperties = new Set(["type", "overflowable"]);
     for (let key in aProperties) {
       if (
         areaIsKnown &&
@@ -767,7 +763,10 @@ var CustomizableUIInternal = {
       // Reconcile new default widgets. Have to do this before we start restoring things.
       this._placeNewDefaultWidgetsInArea(aName);
 
-      if (props.get("legacy") && !gPlacements.has(aName)) {
+      if (
+        props.get("type") == CustomizableUI.TYPE_TOOLBAR &&
+        !gPlacements.has(aName)
+      ) {
         // Guarantee this area exists in gFuturePlacements, to avoid checking it in
         // various places elsewhere.
         if (!gFuturePlacements.has(aName)) {
@@ -780,8 +779,8 @@ var CustomizableUIInternal = {
       // If we have pending build area nodes, register all of them
       if (gPendingBuildAreas.has(aName)) {
         let pendingNodes = gPendingBuildAreas.get(aName);
-        for (let [pendingNode, existingChildren] of pendingNodes) {
-          this.registerToolbarNode(pendingNode, existingChildren);
+        for (let pendingNode of pendingNodes) {
+          this.registerToolbarNode(pendingNode);
         }
         gPendingBuildAreas.delete(aName);
       }
@@ -823,7 +822,7 @@ var CustomizableUIInternal = {
           this.notifyListeners(
             "onAreaNodeUnregistered",
             aName,
-            areaNode.customizationTarget,
+            this.getCustomizationTarget(areaNode),
             CustomizableUI.REASON_AREA_UNREGISTERED
           );
         }
@@ -834,7 +833,7 @@ var CustomizableUIInternal = {
     }
   },
 
-  registerToolbarNode(aToolbar, aExistingChildren) {
+  registerToolbarNode(aToolbar) {
     let area = aToolbar.id;
     if (gBuildAreas.has(area) && gBuildAreas.get(area).has(aToolbar)) {
       return;
@@ -843,41 +842,31 @@ var CustomizableUIInternal = {
 
     // If this area is not registered, try to do it automatically:
     if (!areaProperties) {
-      // If there's no default set attribute at all, we assume that we should
-      // wait for registerArea to be called:
-      if (!aToolbar.hasAttribute("defaultset")) {
-        if (!gPendingBuildAreas.has(area)) {
-          gPendingBuildAreas.set(area, new Map());
-        }
-        let pendingNodes = gPendingBuildAreas.get(area);
-        pendingNodes.set(aToolbar, aExistingChildren);
-        return;
+      if (!gPendingBuildAreas.has(area)) {
+        gPendingBuildAreas.set(area, []);
       }
-      let props = {type: CustomizableUI.TYPE_TOOLBAR, legacy: true};
-      let defaultsetAttribute = aToolbar.getAttribute("defaultset") || "";
-      props.defaultPlacements = defaultsetAttribute.split(",").filter(s => s);
-      this.registerArea(area, props);
-      areaProperties = gAreas.get(area);
+      gPendingBuildAreas.get(area).push(aToolbar);
+      return;
     }
 
     this.beginBatchUpdate();
     try {
       let placements = gPlacements.get(area);
-      if (!placements && areaProperties.has("legacy")) {
-        let legacyState = aToolbar.getAttribute("currentset");
-        if (legacyState) {
-          legacyState = legacyState.split(",").filter(s => s);
-        }
-
-        // Manually restore the state here, so the legacy state can be converted.
-        this.restoreStateForArea(area, legacyState);
+      if (
+        !placements &&
+        areaProperties.get("type") == CustomizableUI.TYPE_TOOLBAR
+      ) {
+        this.restoreStateForArea(area);
         placements = gPlacements.get(area);
       }
 
-      // Check that the current children and the current placements match. If
-      // not, mark it as dirty:
-      if (aExistingChildren.length != placements.length ||
-          aExistingChildren.every((id, i) => id == placements[i])) {
+      // For toolbars that need it, mark as dirty.
+      let defaultPlacements = areaProperties.get("defaultPlacements");
+      if (
+        !this._builtinToolbars.has(area) ||
+        placements.length != defaultPlacements.length ||
+        !placements.every((id, i) => id == defaultPlacements[i])
+      ) {
         gDirtyAreaCache.add(area);
       }
 
@@ -897,13 +886,19 @@ var CustomizableUIInternal = {
       // in the saved state.
       if (gDirtyAreaCache.has(area)) {
         this.buildArea(area, placements, aToolbar);
+      } else {
+        // We must have a builtin toolbar that's in the default state. We need
+        // to only make sure that all the special nodes are correct.
+        let specials = placements.filter(p => this.isSpecialWidget(p));
+        if (specials.length) {
+          this.updateSpecialsForBuiltinToolbar(aToolbar, specials);
+        }
       }
       this.notifyListeners(
         "onAreaNodeRegistered",
         area,
-        aToolbar.customizationTarget
+        this.getCustomizationTarget(aToolbar)
       );
-      aToolbar.setAttribute("currentset", placements.join(","));
     } finally {
       this.endBatchUpdate();
     }
@@ -929,7 +924,7 @@ var CustomizableUIInternal = {
     let document = aAreaNode.ownerDocument;
     let window = document.defaultView;
     let inPrivateWindow = PrivateBrowsingUtils.isWindowPrivate(window);
-    let container = aAreaNode.customizationTarget;
+    let container = this.getCustomizationTarget(aAreaNode);
     let areaIsPanel =
       gAreas.get(aArea).get("type") == CustomizableUI.TYPE_MENU_PANEL;
 
@@ -1184,8 +1179,7 @@ var CustomizableUIInternal = {
       return;
     }
 
-    aPanelContents.customizationTarget = aPanelContents;
-
+    aPanelContents._customizationTarget = aPanelContents;
     this.addPanelCloseListeners(this._getPanelForNode(aPanelContents));
 
     let placements = gPlacements.get(aArea);
@@ -1235,7 +1229,7 @@ var CustomizableUIInternal = {
         continue;
       }
 
-      let container = areaNode.customizationTarget;
+      let container = this.getCustomizationTarget(areaNode);
       let widgetNode = window.document.getElementById(aWidgetId);
       if (widgetNode && isOverflowable) {
         container = areaNode.overflowable.getContainerFor(widgetNode);
@@ -1274,10 +1268,6 @@ var CustomizableUIInternal = {
         true
       );
 
-      if (isToolbar) {
-        areaNode.setAttribute("currentset", gPlacements.get(aArea).join(","));
-      }
-
       let windowCache = gSingleWrapperCache.get(window);
       if (windowCache) {
         windowCache.delete(aWidgetId);
@@ -1350,7 +1340,7 @@ var CustomizableUIInternal = {
           this.notifyListeners(
             "onAreaNodeUnregistered",
             areaId,
-            node.customizationTarget,
+            this.getCustomizationTarget(node),
             CustomizableUI.REASON_WINDOW_CLOSED
           );
           if (areaProperties.has("overflowable")) {
@@ -1367,16 +1357,12 @@ var CustomizableUIInternal = {
       this.notifyListeners("onWidgetInstanceRemoved", widget.id, document);
     }
 
-    for (let [, areaMap] of gPendingBuildAreas) {
-      let toDelete = [];
-      for (let [areaNode ] of areaMap) {
-        if (areaNode.ownerDocument == document) {
-          toDelete.push(areaNode);
+    for (let [, pendingNodes] of gPendingBuildAreas) {
+      for (let i = pendingNodes.length - 1; i >= 0; i--) {
+        if (pendingNodes[i].ownerDocument == document) {
+          pendingNodes.splice(i, 1);
         }
       }
-      for (let areaNode of toDelete) {
-        areaMap.delete(areaNode);
-      }
     }
 
     this.notifyListeners("onWindowClosed", aWindow);
@@ -1457,10 +1443,6 @@ var CustomizableUIInternal = {
       aAreaNode
     );
     this.insertWidgetBefore(widgetNode, nextNode, insertionContainer, areaId);
-
-    if (gAreas.get(areaId).get("type") == CustomizableUI.TYPE_TOOLBAR) {
-      aAreaNode.setAttribute("currentset", gPlacements.get(areaId).join(","));
-    }
   },
 
   findInsertionPoints(aNode, aAreaNode) {
@@ -1475,7 +1457,7 @@ var CustomizableUIInternal = {
       return aAreaNode.overflowable.findOverflowedInsertionPoints(aNode);
     }
 
-    let container = aAreaNode.customizationTarget;
+    let container = this.getCustomizationTarget(aAreaNode);
     let placements = gPlacements.get(areaId);
     let nodeIndex = placements.indexOf(aNode.id);
 
@@ -1625,7 +1607,7 @@ var CustomizableUIInternal = {
       while (
         parent &&
         !(
-          parent.customizationTarget ||
+          this.getCustomizationTarget(parent) ||
           parent == aWindow.gNavToolbox.palette
         )
       ) {
@@ -1639,7 +1621,7 @@ var CustomizableUIInternal = {
             : node;
         // Check if we're in a customization target, or in the palette:
         if (
-          (parent.customizationTarget == nodeInArea.parentNode &&
+          (this.getCustomizationTarget(parent) == nodeInArea.parentNode &&
             gBuildWindows.get(aWindow).has(aWindow.gNavToolbox)) ||
           aWindow.gNavToolbox.palette == nodeInArea.parentNode
         ) {
@@ -1651,7 +1633,7 @@ var CustomizableUIInternal = {
             // customization palette instead of the toolbox palette.
             node.setAttribute(
               "removable",
-              !parent.customizationTarget
+              !this.getCustomizationTarget(parent)
             );
           }
           return node;
@@ -2355,10 +2337,8 @@ var CustomizableUIInternal = {
     );
   },
 
-  // Note that this does not populate gPlacements, which is done lazily so that
-  // the legacy state can be migrated, which is only available once a browser
-  // window is openned.
-  // The panel area is an exception here, since it has no legacy state.
+  // Note that this does not populate gPlacements, which is done lazily.
+  // The panel area is an exception here.
   loadSavedState() {
     let state = Services.prefs.getCharPref(kPrefCustomizationState, "");
     if (!state) {
@@ -2392,7 +2372,7 @@ var CustomizableUIInternal = {
     gNewElementCount = gSavedState.newElementCount || 0;
   },
 
-  restoreStateForArea(aArea, aLegacyState) {
+  restoreStateForArea(aArea) {
     let placementsPreexisted = gPlacements.has(aArea);
 
     this.beginBatchUpdate();
@@ -2421,15 +2401,6 @@ var CustomizableUIInternal = {
         restored = true;
       }
 
-      if (!restored && aLegacyState) {
-        log.debug("Restoring " + aArea + " from legacy state");
-        for (let id of aLegacyState)
-          this.addWidgetToArea(id, aArea);
-        // Don't override dirty state, to ensure legacy state is saved here and
-        // therefore only used once.
-        restored = true;
-      }
-
       if (!restored) {
         log.debug("Restoring " + aArea + " from default state");
         let defaults = gAreas.get(aArea).get("defaultPlacements");
@@ -2749,7 +2720,7 @@ var CustomizableUIInternal = {
     if (gPlacements.has(aArea)) {
       return false;
     }
-    return gAreas.get(aArea).has("legacy");
+    return gAreas.get(aArea).get("type") == CustomizableUI.TYPE_TOOLBAR;
   },
 
   // XXXunf Log some warnings here, when the data provided isn't up to scratch.
@@ -2992,7 +2963,7 @@ var CustomizableUIInternal = {
 
     for (let node of buildAreaNodes) {
       if (node.ownerGlobal == aWindow) {
-        return node.customizationTarget ? node.customizationTarget : node;
+        return this.getCustomizationTarget(node) || node;
       }
     }
 
@@ -3267,7 +3238,7 @@ var CustomizableUIInternal = {
         }
       }
     }
-    addUnskippedChildren(container.customizationTarget);
+    addUnskippedChildren(this.getCustomizationTarget(container));
     if (container.getAttribute("overflowing") == "true") {
       let overflowTarget = container.getAttribute("overflowtarget");
       addUnskippedChildren(
@@ -3284,11 +3255,6 @@ var CustomizableUIInternal = {
   get inDefaultState() {
     for (let [areaId, props] of gAreas) {
       let defaultPlacements = props.get("defaultPlacements");
-      // Areas without default placements (like legacy ones?) get skipped
-      if (!defaultPlacements) {
-        continue;
-      }
-
       let currentPlacements = gPlacements.get(areaId);
       // We're excluding all of the placement IDs for items that do not exist,
       // and items that have removable="false",
@@ -3305,15 +3271,13 @@ var CustomizableUIInternal = {
           let isInDefault = defaultPlacements.includes(item);
           return isRemovable || isInDefault;
         };
-        // Toolbars have a currentSet property which also deals correctly with overflown
-        // widgets (if any) - use that instead:
+        // Toolbars need to deal with overflown widgets (if any) - so
+        // specialcase them:
         if (props.get("type") == CustomizableUI.TYPE_TOOLBAR) {
-          let currentSet = container.currentSet;
-          currentPlacements = currentSet ? currentSet.split(",") : [];
-          currentPlacements = currentPlacements.filter(removableOrDefault);
+          currentPlacements = this._getCurrentWidgetsInContainer(
+            container
+          ).filter(removableOrDefault);
         } else {
-          // Clone the array so we don't modify the actual placements...
-          currentPlacements = [...currentPlacements];
           currentPlacements = currentPlacements.filter(item => {
             let itemNode = container.getElementsByAttribute("id", item)[0];
             return itemNode && removableOrDefault(itemNode || item);
@@ -3328,7 +3292,16 @@ var CustomizableUIInternal = {
           let collapsed = container.getAttribute(attribute) == "true";
           let defaultCollapsed = props.get("defaultCollapsed");
           if (defaultCollapsed !== null && collapsed != defaultCollapsed) {
-            log.debug("Found " + areaId + " had non-default toolbar visibility (expected " + defaultCollapsed + ", was " + collapsed + ")");
+            log.debug(
+              "Found " +
+                areaId +
+                " had non-default toolbar visibility" +
+                "(expected " +
+                defaultCollapsed +
+                ", was " +
+                collapsed +
+                ")"
+            );
             return false;
           }
         }
@@ -3605,8 +3578,6 @@ var CustomizableUI = {
    *                          TYPE_MENU_PANEL;
    *                - anchor: for a menu panel or overflowable toolbar, the
    *                          anchoring node for the panel.
-   *                - legacy: set to true if you want customizableui to
-   *                          automatically migrate the currentset attribute
    *                - overflowable: set to true if your toolbar is overflowable.
    *                                This requires an anchor, and only has an
    *                                effect for toolbars.
@@ -3621,23 +3592,18 @@ var CustomizableUI = {
     CustomizableUIInternal.registerArea(aName, aProperties);
   },
   /**
-   * Register a concrete node for a registered area. This method is automatically
-   * called from any toolbar in the main browser window that has its
-   * "customizable" attribute set to true. There should normally be no need to
-   * call it yourself.
+   * Register a concrete node for a registered area. This method needs to be called
+   * with any toolbar in the main browser window that has its "customizable" attribute
+   * set to true.
    *
    * Note that ideally, you should register your toolbar using registerArea
-   * before any of the toolbars have their XBL bindings constructed (which
-   * will happen when they're added to the DOM and are not hidden). If you
-   * don't, and your toolbar has a defaultset attribute, CustomizableUI will
-   * register it automatically. If your toolbar does not have a defaultset
-   * attribute, the node will be saved for processing when you call
-   * registerArea. Note that CustomizableUI won't restore state in the area,
+   * before calling this. If you don't, the node will be saved for processing when
+   * you call registerArea. Note that CustomizableUI won't restore state in the area,
    * allow the user to customize it in customize mode, or otherwise deal
    * with it, until the area has been registered.
    */
-   registerToolbarNode(aToolbar, aExistingChildren) {
-    CustomizableUIInternal.registerToolbarNode(aToolbar, aExistingChildren);
+  registerToolbarNode(aToolbar) {
+    CustomizableUIInternal.registerToolbarNode(aToolbar);
   },
   /**
    * Register the menu panel node. This method should not be called by anyone
@@ -3676,8 +3642,6 @@ var CustomizableUI = {
    * Add a widget to an area.
    * If the area to which you try to add is not known to CustomizableUI,
    * this will throw.
-   * If the area to which you try to add has not yet been restored from its
-   * legacy state, this will postpone the addition.
    * If the area to which you try to add is the same as the area in which
    * the widget is currently placed, this will do the same as
    * moveWidgetWithinArea.
@@ -3730,11 +3694,7 @@ var CustomizableUI = {
   /**
    * Ensure a XUL-based widget created in a window after areas were
    * initialized moves to its correct position.
-   * This is roughly equivalent to manually looking up the position and using
-   * insertItem in the old API, but a lot less work for consumers.
-   * Always prefer this over using toolbar.insertItem (which might no-op
-   * because it delegates to addWidgetToArea) or, worse, moving items in the
-   * DOM yourself.
+   * Always prefer this over moving items in the DOM yourself.
    *
    * @param aWidgetId the ID of the widget that was just created
    * @param aWindow the window in which you want to ensure it was added.
@@ -3964,9 +3924,8 @@ var CustomizableUI = {
     );
   },
   /**
-   * Get an array of all the widget IDs placed in an area. This is roughly
-   * equivalent to fetching the currentset attribute and splitting by commas
-   * in the legacy APIs. Modifying the array will not affect CustomizableUI.
+   * Get an array of all the widget IDs placed in an area.
+   * Modifying the array will not affect CustomizableUI.
    *
    * @param aArea the ID of the area whose placements you want to obtain.
    * @return an array containing the widget IDs that are in the area.
@@ -3989,9 +3948,8 @@ var CustomizableUI = {
    * Get an array of widget wrappers for all the widgets in an area. This is
    * the same as calling getWidgetIdsInArea and .map() ing the result through
    * CustomizableUI.getWidget. Careful: this means that if there are IDs in there
-   * which don't have corresponding DOM nodes (like in the old-style currentset
-   * attribute), there might be nulls in this array, or items for which
-   * wrapper.forWindow(win) will return null.
+   * which don't have corresponding DOM nodes, there might be nulls in this array,
+   * or items for which wrapper.forWindow(win) will return null.
    *
    * @param aArea the ID of the area whose widgets you want to obtain.
    * @return an array of widget wrappers and/or null values for the widget IDs
@@ -4778,9 +4736,9 @@ function OverflowableToolbar(aToolbarNode) {
 
   this._toolbar.setAttribute("overflowable", "true");
   let doc = this._toolbar.ownerDocument;
-  this._target = this._toolbar.customizationTarget;
+  this._target = CustomizableUI.getCustomizationTarget(this._toolbar);
   this._list = doc.getElementById(this._toolbar.getAttribute("overflowtarget"));
-  this._list.customizationTarget = this._list;
+  this._list._customizationTarget = this._list;
 
   let window = this._toolbar.ownerGlobal;
   if (window.gBrowserInit.delayedStartupFinished) {
diff --git a/browser/components/customizableui/CustomizeMode.jsm b/browser/components/customizableui/CustomizeMode.jsm
index 67e0647165fd..ac3518c8d2c4 100644
--- a/browser/components/customizableui/CustomizeMode.jsm
+++ b/browser/components/customizableui/CustomizeMode.jsm
@@ -494,14 +494,6 @@ CustomizeMode.prototype = {
 
       await this._unwrapToolbarItems();
 
-      if (this._changed) {
-        // XXXmconley: At first, it seems strange to also persist the old way with
-        //             currentset - but this might actually be useful for switching
-        //             to old builds. We might want to keep this around for a little
-        //             bit.
-        this.persistCurrentSets();
-      }
-
       // And drop all area references.
       this.areas.clear();
 
@@ -592,7 +584,7 @@ CustomizeMode.prototype = {
     for (let i = 0; i < numberOfAreas; i++) {
       let area = areas[i];
       let areaNode = aNode.ownerDocument.getElementById(area);
-      let customizationTarget = areaNode && areaNode.customizationTarget;
+      let customizationTarget = CustomizableUI.getCustomizationTarget(areaNode);
       if (customizationTarget && customizationTarget != areaNode) {
         areas.push(customizationTarget.id);
       }
@@ -1191,19 +1183,6 @@ CustomizeMode.prototype = {
     })().catch(log.error);
   },
 
-  persistCurrentSets(aSetBeforePersisting) {
-    let document = this.document;
-    let toolbars = document.querySelectorAll("toolbar[customizable='true'][currentset]");
-    for (let toolbar of toolbars) {
-      if (aSetBeforePersisting) {
-        let set = toolbar.currentSet;
-        toolbar.setAttribute("currentset", set);
-      }
-      // Persist the currentset attribute directly on hardcoded toolbars.
-      Services.xulStore.persist(toolbar, "currentset");
-    }
-  },
-
   reset() {
     this.resetting = true;
     // Disable the reset button temporarily while resetting:
@@ -1218,8 +1197,6 @@ CustomizeMode.prototype = {
       await this._wrapToolbarItems();
       this.populatePalette();
 
-      this.persistCurrentSets(true);
-
       this._updateResetButton();
       this._updateUndoResetButton();
       this._updateEmptyPaletteNotice();
@@ -1243,8 +1220,6 @@ CustomizeMode.prototype = {
       await this._wrapToolbarItems();
       this.populatePalette();
 
-      this.persistCurrentSets(true);
-
       this._updateResetButton();
       this._updateUndoResetButton();
       this._updateEmptyPaletteNotice();
@@ -1931,7 +1906,7 @@ CustomizeMode.prototype = {
     // We need to determine the place that the widget is being dropped in
     // the target.
     let dragOverItem, dragValue;
-    if (targetNode == targetArea.customizationTarget) {
+    if (targetNode == CustomizableUI.getCustomizationTarget(targetArea)) {
       // We'll assume if the user is dragging directly over the target, that
       // they're attempting to append a child to that target.
       dragOverItem =
@@ -1998,7 +1973,7 @@ CustomizeMode.prototype = {
       dragOverItem != this._dragOverItem ||
       dragValue != dragOverItem.getAttribute("dragover")
     ) {
-      if (dragOverItem != targetArea.customizationTarget) {
+      if (dragOverItem != CustomizableUI.getCustomizationTarget(targetArea)) {
         this._setDragActive(
           dragOverItem,
           dragValue,
@@ -2125,6 +2100,9 @@ CustomizeMode.prototype = {
     }
 
     // Skipintoolbarset items won't really be moved:
+    let areaCustomizationTarget = CustomizableUI.getCustomizationTarget(
+      aTargetArea
+    );
     if (draggedItem.getAttribute("skipintoolbarset") == "true") {
       // These items should never leave their area:
       if (aTargetArea != aOriginArea) {
@@ -2132,11 +2110,11 @@ CustomizeMode.prototype = {
       }
       let place = draggedItem.parentNode.getAttribute("place");
       this.unwrapToolbarItem(draggedItem.parentNode);
-      if (aTargetNode == aTargetArea.customizationTarget) {
-        aTargetArea.customizationTarget.appendChild(draggedItem);
+      if (aTargetNode == areaCustomizationTarget) {
+        areaCustomizationTarget.appendChild(draggedItem);
       } else {
         this.unwrapToolbarItem(aTargetNode.parentNode);
-        aTargetArea.customizationTarget.insertBefore(draggedItem, aTargetNode);
+        areaCustomizationTarget.insertBefore(draggedItem, aTargetNode);
         this.wrapToolbarItem(aTargetNode, place);
       }
       this.wrapToolbarItem(draggedItem, place);
@@ -2145,7 +2123,7 @@ CustomizeMode.prototype = {
 
     // Is the target the customization area itself? If so, we just add the
     // widget to the end of the area.
-    if (aTargetNode == aTargetArea.customizationTarget) {
+    if (aTargetNode == areaCustomizationTarget) {
       CustomizableUI.addWidgetToArea(aDraggedItemId, aTargetArea.id);
       this._onDragEnd(aEvent);
       return;
@@ -2489,7 +2467,8 @@ CustomizeMode.prototype = {
   },
 
   _getDragOverNode(aEvent, aAreaElement, aAreaType, aDraggedItemId) {
-    let expectedParent = aAreaElement.customizationTarget || aAreaElement;
+    let expectedParent =
+      CustomizableUI.getCustomizationTarget(aAreaElement) || aAreaElement;
     if (!expectedParent.contains(aEvent.target)) {
       return expectedParent;
     }
diff --git a/browser/components/customizableui/content/jar.mn b/browser/components/customizableui/content/jar.mn
index 858bcc26c06f..08642a640c12 100644
--- a/browser/components/customizableui/content/jar.mn
+++ b/browser/components/customizableui/content/jar.mn
@@ -4,4 +4,3 @@
 
 browser.jar:
   content/browser/customizableui/panelUI.js
-  content/browser/customizableui/toolbar.xml
\ No newline at end of file
diff --git a/browser/components/customizableui/content/toolbar.xml b/browser/components/customizableui/content/toolbar.xml
deleted file mode 100644
index 4cdb8905237a..000000000000
--- a/browser/components/customizableui/content/toolbar.xml
+++ /dev/null
@@ -1,168 +0,0 @@
-<?xml version="1.0"?>
-<!-- This Source Code Form is subject to the terms of the Mozilla Public
-   - License, v. 2.0. If a copy of the MPL was not distributed with this
-   - file, You can obtain one at http://mozilla.org/MPL/2.0/. -->
-
-<bindings id="browserToolbarBindings"
-  xmlns="http://www.mozilla.org/xbl"
-  xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
-  xmlns:xbl="http://www.mozilla.org/xbl">
-
-  <binding id="toolbar">
-    <implementation>
-      <constructor><![CDATA[
-          let scope = {};
-          ChromeUtils.import("resource:///modules/CustomizableUI.jsm", scope);
-
-          if (document.readyState == "complete") {
-            this._init();
-          } else {
-            // Need to wait until XUL overlays are loaded. See bug 554279.
-            let self = this;
-            document.addEventListener("readystatechange", function onReadyStateChange() {
-              if (document.readyState != "complete")
-                return;
-              document.removeEventListener("readystatechange", onReadyStateChange);
-              self._init();
-            });
-          }
-      ]]></constructor>
-
-      <method name="_init">
-        <body><![CDATA[
-          let scope = {};
-          ChromeUtils.import("resource:///modules/CustomizableUI.jsm", scope);
-          let CustomizableUI = scope.CustomizableUI;
-
-          // Searching for the toolbox palette in the toolbar binding because
-          // toolbars are constructed first.
-          let toolbox = this.closest("toolbox");
-          if (toolbox && !toolbox.palette) {
-            for (let node of toolbox.children) {
-              if (node.localName == "toolbarpalette") {
-                // Hold on to the palette but remove it from the document.
-                toolbox.palette = node;
-                toolbox.removeChild(node);
-                break;
-              }
-            }
-          }
-
-          // pass the current set of children for comparison with placements:
-          let children = Array.from(this.children)
-                              .filter(node => node.getAttribute("skipintoolbarset") != "true" && node.id)
-                              .map(node => node.id);
-          CustomizableUI.registerToolbarNode(this, children);
-      ]]></body>
-      </method>
-
-      <method name="insertItem">
-        <parameter name="aId"/>
-        <parameter name="aBeforeElt"/>
-        <parameter name="aWrapper"/>
-        <body><![CDATA[
-          if (aWrapper) {
-            Cu.reportError("Can't insert " + aId + ": using insertItem " +
-                           "no longer supports wrapper elements.");
-            return null;
-          }
-
-          // Hack, the customizable UI code makes this be the last position
-          let pos = null;
-          if (aBeforeElt) {
-            let beforeInfo = CustomizableUI.getPlacementOfWidget(aBeforeElt.id);
-            if (beforeInfo.area != this.id) {
-              Cu.reportError("Can't insert " + aId + " before " +
-                             aBeforeElt.id + " which isn't in this area (" +
-                             this.id + ").");
-              return null;
-            }
-            pos = beforeInfo.position;
-          }
-
-          CustomizableUI.addWidgetToArea(aId, this.id, pos);
-          return this.ownerDocument.getElementById(aId);
-        ]]></body>
-      </method>
-
-      <property name="customizationTarget" readonly="true">
-        <getter><![CDATA[
-          if (this._customizationTarget)
-            return this._customizationTarget;
-
-          let id = this.getAttribute("customizationtarget");
-          if (id)
-            this._customizationTarget = document.getElementById(id);
-
-          if (this._customizationTarget)
-            this._customizationTarget.insertItem = this.insertItem.bind(this);
-          else
-            this._customizationTarget = this;
-
-          return this._customizationTarget;
-        ]]></getter>
-      </property>
-
-      <property name="currentSet">
-        <getter><![CDATA[
-          let currentWidgets = new Set();
-          for (let node of this.customizationTarget.children) {
-            let realNode = node.localName == "toolbarpaletteitem" ? node.firstElementChild : node;
-            if (realNode.getAttribute("skipintoolbarset") != "true") {
-              currentWidgets.add(realNode.id);
-            }
-          }
-          if (this.getAttribute("overflowing") == "true") {
-            let overflowTarget = this.getAttribute("overflowtarget");
-            let overflowList = this.ownerDocument.getElementById(overflowTarget);
-            for (let node of overflowList.children) {
-              let realNode = node.localName == "toolbarpaletteitem" ? node.firstElementChild : node;
-              if (realNode.getAttribute("skipintoolbarset") != "true") {
-                currentWidgets.add(realNode.id);
-              }
-            }
-          }
-          let orderedPlacements = CustomizableUI.getWidgetIdsInArea(this.id);
-          return orderedPlacements.filter(w => currentWidgets.has(w)).join(",");
-        ]]>        </getter>
-        <setter><![CDATA[
-          // Get list of new and old ids:
-          let newVal = (val || "").split(",").filter(x => x);
-          let oldIds = CustomizableUI.getWidgetIdsInArea(this.id);
-
-          // Get a list of items only in the new list
-          let newIds = newVal.filter(id => !oldIds.includes(id));
-          CustomizableUI.beginBatchUpdate();
-          try {
-            for (let newId of newIds) {
-              oldIds = CustomizableUI.getWidgetIdsInArea(this.id);
-              let nextId = newId;
-              let pos;
-              do {
-                // Get the next item
-                nextId = newVal[newVal.indexOf(nextId) + 1];
-                // Figure out where it is in the old list
-                pos = oldIds.indexOf(nextId);
-                // If it's not in the old list, repeat:
-              } while (pos == -1 && nextId);
-              if (pos == -1) {
-                pos = null; // We didn't find anything, insert at the end
-              }
-              CustomizableUI.addWidgetToArea(newId, this.id, pos);
-            }
-
-            let currentIds = this.currentSet.split(",");
-            let removedIds = currentIds.filter(id => !newIds.includes(id) && !newVal.includes(id));
-            for (let removedId of removedIds) {
-              CustomizableUI.removeWidgetFromArea(removedId);
-            }
-          } finally {
-            CustomizableUI.endBatchUpdate();
-          }
-        ]]>        </setter>
-      </property>
-
-    </implementation>
-  </binding>
-
-</bindings>
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
index 6ee849353d04..4d74ed848628 100644
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -195,10 +195,6 @@ toolbar {
   -moz-binding: url("chrome://browser/content/toolbar.xml#toolbar");
 }
 
-toolbar[customizable="true"] {
-  -moz-binding: url("chrome://browser/content/customizableui/toolbar.xml#toolbar");
-}
-
 toolbox {
   -moz-binding: url("chrome://browser/content/toolbar.xml#toolbox");
   -moz-box-orient: vertical;
-- 
2.27.0

